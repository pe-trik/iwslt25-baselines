大家好，我是来自哈佛大学的Jiawei Zhou。 我很高兴向大家介绍我们在在线语义解析用于减少面向任务的对话中的延迟方面的工作。 这项工作是与来自微软语义机器公司的Jason、Michael、Anthony和Sam共同完成的。 在面向任务的对话中，用户通常在说话时与处理来自用户话语请求的系统进行交互。 从用户话语结束到系统响应，通常存在明显的延迟。 在表面之下，用户话语被翻译成一个可执行程序。 然后执行该程序，以便系统能够正确响应。 因为该程序被表示为概述计算的语义图形，其中节点表示一个函数调用，而其子节点是参数。 大的节点标记瞬时操作，但其他节点执行起来很慢。 在我们这里展示的简单例子中，这些程序通常可以是比树结构更复杂的图形。 在这次演讲中，我们提出了这样一个问题：我们是否可以在用户完成话语之前就开始生成程序并执行它，以便系统能够实现更快的响应？ 这就是在线预测和决策问题。 在这个领域还有许多其他例子。 例如，同步翻译，其中现场翻译人员实时将一种语言翻译成另一种语言，智能文本自动补全功能用于猜测用户意图；再比如优步拼车，根据预测的需求将司机送到可能需要的地方。 所有这些场景都有一个共同点。 也就是说，在看到所有输入之前做出决策是有益的。 在我们的案例中，我们将处理在线语义解析，这可能具有挑战性，因为我们必须猜测用户可能会说什么。 而且它也没有得到充分的探索，没有正式的评估指标。 首先，让我们来看看一个普通的系统是如何工作的。 它只在用户话语结束时通过解析对程序进行离线操作。 在这里，字符图形是在看到所有信息之后预测的。 相反，我们提出了一个在线系统，可以对每个话语前缀进行比较。 例如，每当我们看到一个新的令牌，我们就会预测一个新的图形。 请注意，可能存在错误。 在与Barack Obama的泳池派对上，我们得到了一张关于人物和事件主题正确节点的图表，但猜错了时间信息。 这个过程一直持续到我们接收到完整的用户话语。 这将如何影响离线系统中的执行时间线？ 我们将在最后得到程序图形，以便系统可以在这一点上开始执行。 请记住，大的节点是快速操作，因此我们只考虑彩色慢速函数的执行时间线。 首先，这两个“查找人员”函数可以并行执行，由于它们与其他功能没有依赖关系，因此在粉色框中以白色突出显示。 接下来，在获得下层节点的结果后，节点创建事件可以得到执行，然后顶层函数产生，从而完成整个程序。 执行过程是严格的，仅限于程序依赖关系结构，其中一些操作无法并行化，从而导致明显的延迟。 在我们的在线系统中，我们可以随时预测，因此程序可以更早地开始执行。 在这里，在Obama后面的前缀处，我们自信地预测“查找人员”函数应该在程序中，但其余部分可能包含错误，因为它们显示为灰色。 节点的执行可以作为一个步骤立即开始。 然后，使用更多的令牌，我们预测一个全新的图形，但其中一部分已经被执行。 因此，我们只需要考虑我们也有信心的其余节点。 在这里，可以并行执行另一个“查找人员”函数。 同样，我们可能会做出错误的预测。 有了更多的文本，我们就有更多的能力来纠正错误。 比如这里的事件时间，对上午的预测也是正确的。 然后，我们可以按照程序依赖关系结构开始执行其余部分。 通过将执行时间线与话语时间线重叠，我们节省了大量时间。 于是我们提出了在线语义解析的任务。 一个基本假设是，执行时间主导模型预测时间。 因此，我们只能通过提前预测来争取时间。 另一个假设是，由于预测和执行是在后台进行的，所以对用户来说是不可见的。 没有必要保持一致的解析历史记录。 因此，我们在每个令牌之后从头开始解析。 具体而言，我们提出一个两步骤方法。 一个提议的步骤，用于预测具有完整结构的图形，以及一个选择步骤，用于选择此时值得执行的节点。 我们提出的方法有两种变体。 第一种方法将语言模型的完成与完整的话语到图形的解析相结合。 具体来说，Obama之后的前缀首先是通过一个微调过的BART语言模型完成的，然后转换为具有完全离线解析器的程序。 第二种方法直接从用户话语前缀预测程序。 这是通过训练单个在线解析器将每个前缀转换为目标图形来实现的。 这有助于模型学习正确的预期。 更详细地说，我们如何生成这些图形？ 我们通过生成图形的序列版本来表述问题。 每个节点或边都由一个动作表示。 在这里，我们从第一个节点开始。 下面的数字记录了动作历史记录中的绝对索引。 然后，我们得到了第二个节点。 接下来，是它们之间的边。 它包含指向前一个节点索引和边标签的指针。 这里的0表示将最近的节点与第0个动作和下一个节点的下一个边生成的节点连接起来。 这个过程一直持续到生成完整的图形为止。 底层模型基于转换器，具有类似于基于解析器的之前转换的自指向机制。 在生成完整的图形之后，我们获得了与图形不同部分相对应的动作水平概率。 我们根据要执行的阈值启发式选择置信度子图。 稍后，我们将改变阈值，以在延迟减少和执行成本之间实现不同的权衡。 对于在线方法的正式评估，我们提出最终延迟减少或FLR指标。 以下是离线系统如何完成执行时间线的概述。 在在线系统中，执行与话语时间线重叠，因此会提前结束。 FLR被定义为与离线系统相比的减少时间，以执行结束为标志。 我们在两个大的会话式语义解析数据集上进行了实验，即SMCalFlow和TreeDST。 当离线操作时，我们基于图形的解析器在两个数据集上的解析都达到了最先进的性能。 与节点完成的简单基线相比，LM完成模型也达到了非平凡的BLEU增益。 现在，让我们来看看我们对图形解析器前缀的预测准确性。 我们测试y轴上验证数据中生成和go图形之间的图形元组的匹配F1分数，以百分比表示x轴上的每个前缀长度。 这些曲线中的每一条都代表不同的模型，唯一的区别在于训练数据。 最下面的曲线是离线解析器，我们混合不同长度的前缀数据，以将模型转换为在线解析器。 例如，图例前缀80%+表示使用前缀长度大于整个话语长度的80%的前缀数据来训练模型。 左上角是所需的区域。 正如我们所看到的，黑色曲线中的离线解析器在前缀数据上表现不佳。 当我们在训练中混合更多的前缀，曲线向上和向左提升，在所有前缀长度上表现得更好。 然而，在右上角的点中，完整的话语解析表现不受影响。 基于这些强有力的结果，我们可以减少多少延迟？ 我们通过来源令牌的数量来衡量时间，并模拟不同的函数执行时间。 这些曲线显示了FLR指标和执行成本之间的权衡，通过不正确的超额函数成本的数量来衡量。 这是通过改变子图选择阈值来实现的。 较高的阈值选择较少的错误函数，但获得较小的FLR，而较低的阈值更积极地选择和执行程序。 我们比较了我们提出的两种方法和一个基线，这个基线除了直接应用离线解析器用于在线使用外，什么都不做。 左上区域具有最佳FLR和成本权衡。 我们看到我们的两种方法都以很大的幅度击败了基线，并且它们在TreeDST上的表现更加相似。 虽然单个函数的执行速度更快，但往往有更多的运行执行和更低的延迟减少空间。 当单个函数的执行速度较慢时，FLR的改进空间较大。 我们的两种方法在不同的成本区域实现了更好的表现。 总体而言，我们实现了30%到63%的相对延迟减少，具体取决于执行时间和允许的成本。 最后，当允许的成本是三次运行执行时，我们对每种类型函数节点的令牌中平均延迟减少进行了细分。 正如我们所看到的，各方面都有收获。 还有一些函数，在红色条较长的情况下，我们获得了令人印象深刻的延迟减少，例如查找管理员和收件人。 这些都是较低级别的函数，与其他函数没有太多依赖关系。 总之，我们提出了在线语义解析作为新的任务，以探索严格的延迟减少指标。 通过强大的基于图形的语义解析器，我们可以通过具有LM补全和完整解析器的管道方法，或者直接通过基于前缀的学习解析器，来实现相对较好的延迟减少。 而且，我们的方法可以是一个通用框架，并且可以应用于不同域中的其他可执行语义表示。 未来的工作可以探索更智能的预测和执行集成方法。 谢谢聆听！
大家好！ 我将讨论我们在为问题回答任务生成检索增强型反事实方面的工作。 这是我在Google Research实习期间完成的工作，在那里我得到了Matthew Lamm和Ian Tenney的指导。 为了激发这项任务的动机，让我从定义一个反事实开始。 在这项工作中，我们将反事实定义为输入 文本的扰动，其在某种有意义的受控方式上与原始文本不同。 并允许我们对结果或任务标签的变化进行推理。 例如，将单词“引人入胜”改为“令人着迷”，或将“意料之中”改为“单调无聊”，就会改变这篇电影评论的情绪。 同样，在下面的示例中，在问题中添加限定词“women's”，就会改变问题的回答。 与在任务上训练的自然语言处理模型相比，人类通常对这种扰动具有很强的适应性。 为什么会这样？ 数据集可以通过系统性偏见进行采样，从而导致一个简单的决策边界被反事实所违反。 正如这个2D分类问题中所示。 我的工作发现，在训练数据中添加反事实示例可以使模型对这种扰动具有鲁棒性。 那么，如果反事实是有价值的，我们如何才能产生它们呢？ 这个任务对于自然语言处理来说尤其困难，因为这里有三个来自三个不同自然语言处理任务的例子。 正如大家所看到的，违反结果之间的决策边界的例子需要通过扰乱此处下划线的文本的某些属性来精心制作。 这可以通过人类注释来完成，但这样做不仅昂贵，而且还带有偏见。 之前的一些工作侧重于使用句法树或语义角色标签。 但是，由这些技术生成的扰动集受到语义框架的限制。 最近的工作使用掩码语言模型来填充文本的掩码部分以更改标签。 但是，找出文本的哪些部分会造成扰动是一项具有挑战性的工作。 具体而言，在为问题回答生成反事实产生方面存在更多的挑战。 这项任务需要背景知识。 例如，为了扰乱原来的问题，《夺宝奇兵之末日神庙》是一部前传吗？ 我们需要了解《夺宝奇兵》系列的其他电影，才能回答这样的问题：《夺宝奇兵之法柜奇兵》是一部前传吗？ 此外，随机扰动可能导致无法用现有证据回答或具有错误前提的问题。 而且，一些问题扰动可能导致与原始输入的显著语义偏差。 例如，这个问题是印第安纳·琼斯是否在《末日神庙》中奴役儿童？ 我们提出一种非常简单但有效的技术，称为检索生成过滤器或RGF，以解决问题的反事实扰动，并旨在解决上述所有其他挑战。 RGF背后的核心直觉是，产生扰动所需的必要背景信息可能存在于问题回答模型造成的未遂事件中。 例如，最先进的模型REALM为“谁是里士满足球俱乐部的队长”这个问题提供以下前k个回答？ 虽然它确实提取了原始参考段落并回答“Trent Cotchin”作为首选。 它还检索了其他段落和回答，可用于指导问题扰动。 例如，它还提取了另外两个回答，分别对应于同一俱乐部预备队和女队的队长，这可能会带来有趣的编辑。 总而言之，RGF首先检索前k个最相关的回答和上下文中与参考回答不匹配的上下文。 在这一步骤之后，问题生成模型以这些备选回答为条件，生成一个与它们相对应的问题。 最后，我们可以基于最小化或基于我们有兴趣引入的语义扰动的类型来过滤生成的问题。 更详细地检查检索的每个步骤，我们使用检索然后读取模型，如REALM，将原始问题作为输入，并使用像维基百科这样的大型语料库。 它由两个模块组成。 检索器模块对密集的段落索引执行相似性搜索，以检索与问题最相关的前k个段落。 然后，阅读器模块从每个段落中提取一个跨度作为潜在的回答。 在大多数情况下，REALM会检索黄金段落和回答。 然而，在这项工作中，我们更感兴趣的是它进一步检索的回答案和上下文。 在下一步问题生成中，我们使用这些备选回答和上下文来重新生成与这些备选回答相对应的新问题。 问题生成模型是一个预先训练好的文本到文本的转换器，它在NQ数据上进行了微调，以针对已在上下文中标记的回答生成一个问题。 在推理过程中，我们提供问题生成模型、备选回答以及我们在前一步中检索到的上下文。 例如，对于“谁是里士满足球俱乐部的队长？”这个询问，REALM检索由Jess Kennedy担任队长的俱乐部女队的段落，而问题生成模型生成询问“谁是里士满足球俱乐部有史以来第一支女子足球队的队长？” 它有一个特定的语义扰动。 通过类似的方式，我们也会得到一些这样的询问，比如“谁是里士满VFL预备队的队长？” 或者“格雷厄姆在去年的总决赛中打败了谁？” 最后，我们根据一些期望的特征过滤掉生成的询问的一个子集。 如前所述，我们希望确保新的问题仍然在语义上接近原始问题。 对于不需要额外监督的过滤技术，我们只需保留与原始问题有较小令牌标签编辑距离的新问题。 例如，我们删除了“格雷厄姆在去年的总决赛中打败了谁？”的问题 。 因为它与原始问题有一个较长的编辑距离。 在我们的实验中，我们证明了这个简单的启发式可以用来增强训练数据并将其排入队列。 我们还试验了一种基于语义扰动类型的过滤策略。 为此，我们使用了一个名为QED的通用询问分解框架。 QED确定问题的两个部分，一个是谓词，一个是引用。 引用是问题中与上下文中的实体相对应的名词短语。 谓词基本上是问题的剩余部分。 例如，我们能够将“谁是里士满足球俱乐部有史以来第一支女子足球队的队长”的询问分解为两个参考：里士满足球俱乐部女子足球队和谁担任队长X的谓词。 在NQ的引用谓词注释上训练的模型为我们提供了这个问题的分解。 根据QED分解原始问题和生成的问题，使我们能够对生成的反事实进行分类评估。 具体而言，我们得到两组问题。 在保留谓词的同时进行引用更改的问题，以及进行谓词更改并可选地添加引用的问题。 例如，“谁是里士满VFL预备队的队长？”是进行引用更改。 而“谁在俱乐部穿9号球衣”是进行谓词更改。 我们现在评估当增强到训练数据时RGF扰动的有效性。 因此，为了有效地评估反事实增强的有效性，我们特别对两个强大的数据增强基线进行实验。 第一个基线称为随机回答和问题生成，添加了与原始问题没有关系的数据。 也就是说，段落和回答都是从维基百科中随机抽取的。 这个基线基本上增加了更多看起来像NQ的数据。 通过第二个基线黄金回答和问题生成，我们特别更新了我们方法的检索部分。 在这里，备选回答是从包含黄金回答的相同段落中选择的。 在模型能够访问问题和上下文的情况下，基线和RGF增强在阅读理解方面的表现如何？ 我们对域数据集中的六个数据集进行了实验，并在这里展示了结果，其中数据是训练数据，在增强中增加了一倍。 我们发现两个数据增强基线都无法改善我们的域泛化。 事实上，在原始数据上训练的六个模型的集合似乎是最具竞争力的基线。 与基线相比，我们发现RGF反事实能够提高域外表现，同时保持域内表现。 这表明通过反事实增强填补模型的推理空白，比从训练分布中添加更多的数据更有效。 此外，我们发现，使用检索对备选结果或回答进行抽样，对于有效的CDA非常重要。 我们还尝试了开放域 问答设置，其中模型只看到问题，然后我们再次对域数据集中的四个数据集进行评估。 我们发现基线模型对域外泛化并不那么有效。 然而，使用RGF的数据增强显示出更显著的改进。 我们甚至在域NQ数据集中进行了改进。 我们假设反事实数据增强有助于模型学习更好的询问编码，用于非常相似的询问。 最后，我们还评估了模型在原始问题的局部邻域中提高一致性的能力。 一致性衡量的是模型正确回答问题的比例，其中原始问题和反事实询问都得到了正确回答。 这显然有助于我们衡量模型对原始输入邻域中的小扰动的鲁棒性。 我们对五个数据集进行了实验，这些数据集包含语义上彼此接近的问题对。 除了已经可用的三个数据集AQA、AmbigQA和QUOREF-对比集之外，我们还根据RGF反事实与原始NQ问题配对，评估它们是否经历了谓词变化或引用变化。 这些子集在内部进行了注释，以消除噪声，并作为资源提供。 所有基线都无法显著提高与整体模型的一致性，只能小幅提高一致性。 然而，RGF反事实增强在先前的数据集和我们为引用和谓词扰动策划的两个子集上的一致性方面都取得了令人印象深刻的提高。 请注意，增强RGF数据不会因扰动类型而产生偏差，只有评估集才会产生偏差。 事实上，对生成的各种反事实的定性检查表明，生成的问题包含几种不同的扰动。 例如，这个关于明尼苏达州沃尔纳特格罗夫人口的原始问题在不同维度上受到扰动，如城镇、州、国家，以及不同的谓词，如位置、贫困、学校数量。 扰动的音频是上下文特定的。 例如，这另一个问题与温布尔登网球公开赛单打锦标赛有关，扰动取决于比赛类型、锦标赛类型或比赛结果。 最后的总结：我们解决了反事实数据增强和信息扰动寻求询问的任务，并通过逆转生成方法来解决其独特的挑战，通过使用模型的未遂事件来过度生成，并根据扰动类型或最小化进行过滤。 我们发现这种技术不需要额外的监督，并且这些示例被标记用于增强。 增强改善了域外泛化和邻域一致性。 我们发现，RGF反事实在语义上是多样化的，不会在增强过程中引入偏差。 谢谢！
大家好，我是Elena，我将向大家介绍我们的工作——检测西班牙语中的未同化借词：注释语料库和建模方法。 我们将讨论什么是词汇借用、我们提出的任务、我们已经发布的数据集，以及我们探索的一些模型。 首先，什么是词汇借用，为什么它作为一个自然语言处理任务很重要？ 总的来说，词汇借用是将一种语言的单词并入另一种语言中。 例如，在西班牙语中，我们会使用来自英语的单词。 这里有几个例子，比如podcast、app和online crowdfunding等单词，所有这些都是我们有时会在西班牙语中使用的英语单词。 词汇借用是一种语言学借用，本质上是在一种语言中再现其他语言的模式。 借用和语码转换有时会被比较并被描述为一个连续体，语码转换就是双语者同时混合两种语言时所做的事情。 然而，词汇借用和语码转换之间存在一些差异。 我们将重点讨论词汇借用。 语码转换是由双语者完成的，根据定义，语码转换并没有融入到任何一种正在使用的语言中，而词汇借用也可以由单语者完成。 借词要符合接受者语言的语法。 借词最终可以融入到接受者的语言中。 那么，为什么说借词是一种有趣的现象呢？ 从语言学的角度来看，借词是语言如何变化以及它们如何相互作用的一种表现。 而且词汇借用也是新词的来源之一。 这里有一些词汇借用的例子，这些借词已经作为新词融入到西班牙语语言中。 就自然语言处理而言，借词是词汇单词之外的一个常见来源。 而事实上，自动地检测词汇借用已被证明对自然语言处理下游任务有用，例如解析、文本-语音合成或机器翻译。 人们越来越关注英语对其他语言的影响，尤其是与英语词汇借用有关的影响，这些借词有时被称为英语的借词。 在这里，我们举了一些关于这些语言中借词的自动检测工作的例子。 因此，我们提出的任务是检测西班牙语新闻专线中未同化的词汇借用。 也就是说，我们感兴趣的是提取从其他语言中借用的单词，这些单词正在西班牙语报纸中使用，但尚未融入或同化到接收者的语言中。 所以还没有融入西班牙语。 让我来举个例子。 这是一个西班牙语的句子：Las Prendas Bestsellers Se estampan con motivos florales，Animal print o retales tipo patchwork. 嗯，正如大家所看到的，有三个跨度的文本实际上是英语单词，比如bestseller、animal print和patchwork。 这些是我们所感兴趣的提取和检测的跨度类型。 之前已经有关于英语检测的单词，由西班牙语新闻专线上用于英语检测的CRF模型组成。 这个模型取得了86分的F1分数。 但是在数据集和建模方法方面都有一些局限性。 该数据集只关注新闻的一个来源，并且仅包含头条新闻。 此外，在训练集和测试集中出现的借词也有重叠。 这使我们无法评估建模方法是否可以实际概括到以前未见过的借词。 因此，我们的目标是解决任务中的一些局限性。 为此，首先我们创建了一个新的数据集。 我们的目标是创建一个新的数据集，该数据集使用词汇借词进行注释，目的是创建一个尽可能困难的测试集。 因此，训练集和测试集之间的单词和主题的重叠程度会很小。 因此，测试集来自我们在训练集中看不到的来源和日期。 在这里大家可以看到，在时间上没有重叠。 而且，测试集的借词密度也很高。 给大家看一些数字：如果训练集每1000个令牌包含6六个借词，那么测试集每1000个令牌包含20个借词。 测试集包含了尽可能多的词汇表外的单词。 事实上，测试集中92%的借词都是OOV。 因此，在训练期间看不到它们。 而语料库总的来说是由来自不同来源的西班牙报纸的文本集合而成的。 而且它是用两个标签手工注释的。 一个标签用于注释英语词汇借词，这是西班牙语中的大多数词汇借词，然后另一个标签用于注释来自其他语言的借词。 我们使用CONLL格式和BIO编码，这样我们就可以编码单个令牌借词，比如app，或多个令牌借词，比如machine learning。 这些是语料库的数字。 如大家所见，这相当于大约有37万个令牌。 这包含了被标记为英语的跨度数量和标记为其他借词的跨度数量，以及它们中有多少是独一无二的。 这里有几个关于数据集集合的例子。 正如大家所看到的，例如，在第一个例子中，我们有一个借词的批处理，这是一个多单词借词。 而且我们已经使用BIO编码对其进行了注释。 因此，BIO用于西班牙语中的单词，而不是用于未借用的单词。 在这个第二个例子中，大家可以看到benching和crash这两个词也被标记为是从英语借来的。 因此，一旦我们拥有了数据集，我们就为提取和检测这些词汇借词的任务探索了几个模型。 我们首先尝试的是条件随机场模型。 这是在之前工作中使用过的模型。 我们使用了与那次工作中相同的手工制作的特征。 如大家所见，这些都是特征。 这些都是二进制特征，例如大写的单词或令牌？ 是标题标签吗？ 是引号吗？ 诸如此类的东西，这是人们在命名实体识别任务中所期望的特征类型。 这就是我们得到的结果。 我们使用具有手工制作特征的CRF模型获得55分的F1分数。 与报告的86分F1分数相比，这是一个巨大的差异，F1分数是用相同的CRF模型，相同的特征，但是在不同的数据集上获得的结果，也用于西班牙语词汇借用检测。 因此，这证明了我们创建的数据集更加困难，我们需要探索更复杂的模型用于这些任务。 因此，我们测试了两个基于转换器的模型。 我们使用了BETO，这是一个单语BERT模型，针对西班牙语和多语言BERT训练的模型。 我们通过HuggingFace的转换器库使用这两个模型。 这就是我们得到的结果。 正如大家所看到的，多语言BERT在开发集和测试集以及所有指标上的表现都优于BETO。 正因为如此，我们有了一个比较的想法，CRF模型获得了82分。 CRF模型获得了55分，获得了55分的F1分数，而多语言BERT获得了82分，这是一个很大的差异。 所以，一旦我们得到了这些结果，我们就会问自己另一个问题，那就是，我们能否找到一个BiLSTM-CRF模型，为它提供不同类型的嵌入，嵌入对不同类型的语言信息进行编码，并执行优于基于转换器的模型获得的结果？ 因此，为了做到这一点，我们进行了一些初步实验，我们使用flare库通过BiLSTM-CRF模型运行这些实验。 我们尝试了不同类型的嵌入，比如基于转换器但也是快速的文本、字符嵌入等等。 我们发现，基于转换器的嵌入比非情境化的嵌入表现得更好，英语BERT和西班牙语BETO嵌入的组合比多语言BERT嵌入表现得更好。 BPE嵌入产生了更好的F1，字符嵌入产生了更好的调用。 考虑到这一点，这些是我们获得的表现最好的结果。 两个模型均为使用flare的BiLSTM-CRF模型。 一个是BETO和BERT 嵌入和BPE，另一个是BETO和BERT嵌入和BPE，还有字符嵌入。 最后一个是在测试集上产生最高F1分数的那个，尽管在开发集上的最高分数是由没有字符嵌入的那个获得的。 请记住，我们使用多语言BERT获得的最佳结果是在开发集中获得了76分的F1分数，在测试集中获得了82分。 因此，与那些结果相比，这是一种进步。 最后，我们问了自己另一个问题，那就是在语码转换中，词汇借用检测能否被框定为语言识别的迁移学习？ 因此，我们运行了使用flare运行的相同的BiLSTM-CRF模型，但我们使用了语码转换嵌入，而不是使用这些未调整的基于转换器的BETO和BERT嵌入。 什么是语码转换嵌入？ 这些是经过微调的基于转换器的嵌入，这些嵌入已经在LinCE语码转换数据集的西班牙语英语部分经过预训练 用于 语言识别。 LinCE是一个关于语码转换的数据集，其中有一个关于西班牙语英语，西班牙语英语语码转换的部分。 因此，我们给我们的BiLSTM-CRF提供了语码转换嵌入和可选的字符嵌入、BPE嵌入等等。 我们得到的最好结果是84.22分，这是我们在测试集上尝试的所有模型中最高的分数。 尽管我们在开发集上获得的最好结果F1评分为79分，低于使用未调整嵌入的BiLSTM-CRF获得的最好结果。 因此，从我们的工作中得出了一些结论。 我们已经创建了一个新的西班牙语新闻专线数据集，使用未同化的词汇借词进行了注释。 与之前的资源相比，这个数据集的借词密度更高，并且OOV也更丰富。 我们已经探索了四种类型的模型 用于 词汇借用检测。 呃。在错误分析方面，调用对于所有模型来说都是一个薄弱环节。 正如大家在这里看到的，一些常见的假阴性包括大写的借词，例如在英语和西班牙语中都存在的单词。 同样有趣的是，BPE嵌入似乎提高了F1分数。 而字符嵌入似乎可以改善调用。 这是一个有趣的发现，也许我们可以在未来的工作中探索。 呃。嗯，以上就是我要介绍的所有内容。 非常感谢大家的聆听。
我叫Antoine。 我是马萨诸塞大学阿默斯特分校的一名博士生。 我将介绍我们的论文《KinyaBERT：一种形态学意识的基尼亚卢旺达语语言模型》。 今天，我将谈一谈这项研究的动机。 然后，我将详细介绍KinyaBERT模型的架构。 然后我会谈谈我们的实验结果，最后得出一些结论。 我们都知道，最近的自然语言处理进步是通过使用预训练语言模型（如BERT ）实现的。 然而，仍然存在许多限制。 由于大多数形态学上丰富的语言所表达的形态学很复杂，我使用的普遍存在的字节对编码标记化算法无法提取有效表达所需的确切子词词汇单位，即意义语素。 例如，这里我们有三个基尼亚卢旺达语单词，其中有几个语素，但BPE算法无法提取它们。 这是因为某些形态化规则产生不同的表面形式，隐藏了确切的词汇信息，而完全基于表面形式的BPE无法访问此词汇模型。 第二个挑战是，即使人们能够使用甲骨文形态化分析器，用语素替换BPE令牌也不足以表达形态学组合性。 这次研究涉及的第三个空白是，新的预训练语言模型通常是在高资源语言上进行评估的。 我们还需要评估它们在低资源和多样化语言上的适用性。 所以，我们提出KinyaBERT，它是BERT架构的一个简单但有效的改编，旨在更有效地处理形态上丰富的语言。 我们评估了基尼亚卢旺达语的KinyaBERT，这是一种低资源形态上丰富的语言，在东非和中非有超过1200万人使用。 模型的输入是句子或文档。 例如这句，John twarahamubonye biradutangaza，意思是，我们惊讶地发现John在那里。 正如大家所看到的，基尼亚卢旺达语单词包含几个语素，每个语素包含不同的信息。 所以，在我们的模型中，我们将这个句子或文档传递给形态分析器。 然后生成包含在每个单词中的词素。 语素通常由词干和零个或多个词缀组成。 词缀可以表示动词中的时态、方面、主语或宾语，更多时候与班图语的名词类主语和宾语有关。 形态分析器还为每个单词生成语音标签的一部分。 在这一步之后，我们为语音标签的部分进行嵌入。 词缀的嵌入。 以及词干的嵌入。 这些是形态学层面的，这些是形态学层面的嵌入。 然后，我们将这些嵌入通过形态学编码器传递，这是一个独立应用于每个单词的小型转换器编码器。 它们的输出是情境化的向量，每个单词都有形态化的信息。 现在，我们进行组合，其中与语音部分相对应的形态化嵌入与词干连接在一起。 我们进一步将它们与句子级别的另一个词干嵌入连接起来。 然后，我们对主句子或文档编码器形成一个输入。 最终输出是情境化嵌入，可用于下游自然语言处理任务。 对于形态分析器，我们使用有限状态二级形态学原则，并根据基尼亚卢旺达语语言定制实现。 我们有效地对所有基尼亚卢旺达语单词的形态进行建模，包括动词、名词、指示和所有格代词、数字等等。 我们使用语音标记算法的无监督部分。 一阶因子模型用于说明形态学概率，基本上是由形态分析器分配的概率。 我们还考虑了部分语音标签的优先顺序，以及输入单词中存在的句法协议。 部分语音标记器使用bidi双向推理，这种方法改进了更经常用于解码的Viterbi算法。 这里有一些注释对于位置编码。 第一，形态学编码器不使用任何位置编码。 这是因为每个语素在形态化模型中占据了一个已知的位置。 因此，当给出语素时，位置信息是固有的。 第二，句子编码器使用所谓的不受约束的相对位置嵌入，这是最近在ICLR会议上发表的。 这种位置嵌入本质上将位置相关性从令牌分离到令牌注意力计算。 与BERT类似，我们使用掩码语言模型预训练目标。 从本质上讲，我们必须预测与单词相关的词干和词缀。 在预训练期间，所有单词的15%被认为用于预测，其中80%被屏蔽，10%与随机单词交换，10%保持不变。 对于词缀预测，我们面临一些多标签分类问题。 为此，我们要么将词缀组合成固定数量的集合，并将该集合预测为一个类标签。 另一种选择是预测词缀概率向量。 我们在实验中对这两种方法进行了评估。 我们用大约2.5千兆字节的基尼亚卢旺达语文本对KinyaBERT进行预训练，并将其与三个基线模型进行比较。 一个是称为XLM-R的多语言模型，它是在由多种语言组成的大型文本语料库上训练的。 另外两个基线是使用字节对编码算法或使用形态分析而不使用两层转换器编码器架构对同一基尼亚卢旺达语文本进行预训练的。 所有模型都是在基础架构中配置的，基础架构的参数大约在100到1000万之间，基尼亚卢旺达语和KinyaBERT使用的参数数量最少。 除多语言外，所有模型都经过预训练用于32000梯度更新，每批次的批量大小为2560序列。 我们在三组任务上评估预训练模型。 其中一个是GLUE基准，它经常用于评估预训练语言模型的有效性。 我们通过使用Google翻译将原始基准数据翻译成基尼亚卢旺达语来获得GLUE基准数据。 第二个任务是基尼亚卢旺达语命名实体识别基准，这是一个由训练有素的母语使用者注释的高质量数据集。 第三个是新闻分类任务，我们从几个网站中提取新闻文章，并收集作者分配的分类标签，然后基本上尝试预测相同的类别。 现在我们来看看结果。 对于GLUE基准，我们发现KinyaBERT始终优于基线模型。 在这里，我们展示了十次微调运行的平均表现。 我们还对Google翻译生成的翻译进行了用户评估。 基本上，用户用户对大约6000个例子进行了评分，按照从1到4的等级进行评分，评估翻译的质量。 其结果是，许多翻译是杂乱无章的。 但是，所有模型都必须应对相同的翻译噪声，并且模型之间的相对性能仍然是值得注意的重要因素。 对于命名实体识别任务，我们还发现KinyaBERT给出的表现最好，并且词缀分布回归变体表现最佳。 这些结果也是十微调运行的平均值。 对于新闻分类任务，我们发现结果好坏参半。 之前关于基尼亚卢旺达语文本分类的工作发现，简单的关键词检测就足以解决这个特定的任务。 因此，使用预训练语言模型的收益较少。 关于新闻分类这个特殊任务。 我们还进行了一项消融研究，看看是否有其他结构可以提高表现。 对于GLUE基准，我们发现使用词缀集始终表现更好，而词缀概率回归目标在命名实体识别上产生最佳表现。 此外，通过查看微调的低分数，我们发现KinyaBERT在大多数情况下具有更好的收敛性。 总之，这项工作已经证明了在预训练语言模型中明确使用形态学信息的有效性。 所提出的两层转换器编码器架构能够捕获形态学复杂性形态学组合性，这是形态学丰富语言的一个重要方面。 这些发现应该能激发对形态学感知语言预训练语言模型的进一步研究。
大家好，我叫Michał Pietruszka，我很高兴向大家介绍这篇题为《用可训练的表示池来对转换器模型进行稀疏化》的论文。 这是ApplicaAI与Lukasz Borchmann和Lukasz Garncarek合作完成的一项工作。 让我先谈谈我们的工作目标。 我们的方法在考虑长输入的情况下效果不错。 粗略地说，这意味着超过2000个令牌的任务订单和输入，并且目标比提供的输入要短。 这在自然语言处理中有一些具体的应用。 例如，可以想象，给定一份很长的文档，需要对其进行总结、分类，回答有关它的问题，提取信息或一些关键短语。 让我回顾一下普通的转换器，以及我们和它的注意力复杂性问题，这取决于输入行的平方。 在普通的转换器中，在完全注意力连通的情况下，必须计算每个令牌与其他令牌之间的关系。 注意力的计算复杂性，这取决于层l的数量，序列长度n，另一个序列长度以及表示的维度。 类似地，在解码器的交叉注意力中，对于右侧的这张图片，这里唯一的区别是，在这种情况下，目标令牌正在关注输入令牌。 这也可以从这个公式中看出来。 BLEU分数表示必须计算的关系。 在完全注意力的情况下，我们需要计算输入 序列中的每个关系。 现在，我们看看当我们有一个分块编码器时会发生什么，该编码器通过限制令牌连接来工作，这样它们只能看到附近的其他令牌。 文本是以块的形式读取的，这可以大大减少编码器端的计算数量，但并不能提高解码器的交叉注意力，因为无论如何，每个输入令牌都会传递给解码器。 这种方法通常被称为解码器中的融合。 这里的改进可以解释为将n的一个依赖关系更改为另一个表示块大小的常数m。 我们的主要观察结果是，大多数令牌与各种任务都是不相关的，几乎可以完全忽略。这一点在幻灯片上得到了例证。 输入的唯一部分与期望的输出相关。 例如， 阅读一篇文章时，可以先用荧光笔标出最重要的部分，然后只从中间阶段开始根据这一部分写出摘要。 因此，突出显示和决定当前令牌是否对生成摘要至关重要的成本而言是便宜的，并且仅取决于令牌的表示。 突出显示的令牌可以进行池化。 多亏了我们的top k运算符，其成本可以忽略不计。 当考虑整个输入时，从缩短的输入生成摘要的成本也比普通模型低得多。 但这里有一个问题。 如何选择重要的令牌并将梯度反向传播到该选择？ 我们解决的根本问题是提出可训练的选择机制。 一种可以允许在训练期间反向传播梯度的方法，以便网络能够学习选择最重要的令牌。 更确切地说， 给定从简单线性层获得的一些嵌入下划线，任务是返回得分最高的嵌入。首先，对序列进行排列，并准备成对，以便将得分较高的向量与得分较低的向量一起使用。 接下来，使用分数上的提升softmax计算权重。 在每一轮锦标赛之后，新的向量和分数被组成为这些对与所获得的权重的线性组合。 因此，简而言之，我们通过对它们的分数执行softmax来线性地组合它们。 并且当组合两个令牌时，可以产生一些噪声。 但它也允许梯度传播到所有输入嵌入。 简而言之，我们提出的可训练的top k是基于在每个步骤中执行软选择这样的锦标赛。 而从另一个角度来看，表示池化是在编码器层之后。 首先，对每个表示进行评分，然后只有得分最高的那些表示才会被传递到下一层。 编码可以像标准转换器架构一样在全长输入上执行。 然而，它还可以在固定长度的块中处理固定长度的文本，并在全局范围内选择最佳的表示。 下面是一个在编码器之后引入的表示池的例子。 这直接影响了交叉注意力的原因，它不取决于输入长度N，而是常数K，代表池化长度。 这个常数通知我们有多少个表示被选择并传递给解码器。 从较短的文本生成摘要比之前的解决方案要便宜得多。 由于序列长度可以缩短大的因子。 例如，我们在实验中成功地使用了比n值小16倍甚至64倍的k值。 请注意，分块编码和自我注意力的有益影响是持续的。 请记住，注意力的计算成本取决于输入长度的平方。 在编码过程中尽早减少输入可以显著降低成本。 对于金字塔模型，我们缩小了每个选定层输出上表示的大小，导致随着编码的进行，计算成本呈指数级降低。 正如大家所看到的，这里完整的编码器的总计算成本不到全尺寸第一层成本的两倍。 当较早引入池化时，所有紫色方块的总和都受限于一个常数，而不取决于层l的数量。 而是取决于常数c，常数c可能受到网络内池化层的放置的影响。 我们的改进以8000个令牌长的输入为基准。 该图显示，当使用池化时，网络深度的最佳可扩展性得到了实现。 这里我们可以注意到，在如此长的输入上，训练24层的金字塔可能比训练两层的普通转换器更便宜。 更不用说，对于这么长的输入，普通转换器是多么容易耗尽内存。 我们的趋势金字塔与其他基线的qual质量qual定性比较是在长文档总结任务上执行的，或者给定来自arXiv或PubMed的文章主体，而任务是生成其摘要。 因此，人们可以看到分块（我们的基线）的表现与最近最先进模型的水平相当，而金字塔则保留或提高这一竞争基线的表现。 与此同时，与分块基线相比，我们的模型训练速度提高了80%，推理速度提高了450%以上。 这两个模型的参数计数要低得多，并且都是根据所选的任务从头开始训练的。 之前实现类似表现的方法必须使用更多的参数，并利用预训练基础模型和额外的语言预训练目标来实现类似的表现。 我们邀请大家阅读我们的完整论文并使用我们的GitHub代码。 感谢大家的观看。
