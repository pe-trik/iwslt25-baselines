こんにちは。ハーバード大学のJiawei Zhouです。 タスク指向のダイアログにおけるオンライン意味論的構文解析のレイテンシ削減に関する研究を発表できることを嬉しく思います。 これは、Microsoftの意味論的マシンのジェイソン、マイケル、アンソニー、サムとの共同研究です。 タスク指向のダイアログでユーザーが対話するシステムは、通常、話すことで発せられるユーザーの発話からの要求を処理します。 ユーザー発話の終了から、システムの応答まで、しばしば目立った遅延があります。 内部では、ユーザーの発話が実行可能なプログラムへ翻訳されます。 そして、システムが適切に応答できるように実行されます。 そのプログラムは、計算を概要する意味論グラフとして表現され、ここでノードは関数の呼び出しと示し、その子は引数を表します。 大きなノードは、瞬時に動作しますが、その他は実行が遅いです。 ここで示された簡単な例のように、これらのプログラムはしばしばツリー構造を超えてより複雑なグラフになることがあります。 ここでは、システムがより早い応答が達成できるよう、ユーザーが発話を終わる前にプログラムの生成を開始し、実行できるか？という質問について追求していきます。 これは、オンライン予測と決定の問題です。 この領域には他にもたくさんのものがあります。 例としては、通訳者が、一つの言語から他の言語にリアルタイムで翻訳をする同時翻訳、ユーザーの意図を推測するスマートテキストの自動補完、需要予測に基づいて必要とされる可能性のある場所にドライバーを送るUberプールなどがあります。 これらのシナリオのすべてには共通点があります。 すべての入力を見る前に意思決定を下すのは有益であるということです。 ここでは、オンライン意味論的構文解析を扱います。これはユーザーが言うかもしれないことを推測しなければならないので、困難となる可能性があります。 そして、公式な評価メトリックがない、十分に調査されていない領域でもあります。 まず、通常のシステムの仕組みを見ていきましょう。 ユーザー発話の最後のみにプログラムに構文解析をすることで、オフラインで動作します。 ここでは、文字グラフは、すべての情報を見た後に予測されます。 対照的に、私たちはすべての発話の接頭辞で比較するオンラインシステムを提案しています。 たとえば、新しいトークンを見るたびに、新しいグラフを予測します。 エラーがある可能性に注意してください。 バラク・オバマとのプールサイドパーティーでの位置では、人物とイベント主題についての右ノードのグラフがありますが、タイミング情報が間違っていると思われます。 このプロセスは、完全にユーザー発話を受け取るまで続きます。 これがオフラインのシステムでは、どのように実行のタイムラインに影響を与えるでしょうか？ プログラムグラフは最後に得るので、システムはこの時点で実行開始できます。 大きなノードは操作が高速で、色付けした遅い関数の実行タイムラインのみを考慮することを覚えておいてください。 まず、二つのfind person関数は並行して実行できます。関数はそれぞれ依存関係がないので、ピンク色のボックスで白に強調されています 次に、より低いレベルのノードから結果を得た後、ノード作成のイベントが実行され、そしてトップのyield関数が実行されてプログラム全体が終了します。 実行プロセスは厳密であり、プログラム依存性構造に制限されています。一部の操作は並行実行できないため、顕著な遅延が起こることがあります。 私たちのオンラインシステムでは、先に進むにつれて予測し、プログラム実行を早期に開始することができます。 ここでは、オバマのあとの接頭辞で、find person関数はプログラム内にあるべきと自信を持って予測していますが、残りはグレーアウトされるためエラーが含まれている可能性があります。 ノードの実行は、ステップごとにすぐ開始することができます。 その後、より多くのトークンで、私たちは、まったく新しいグラフを予測しますが、その一部はすでに実行されています。 したがって、私たちは、私たちが自信を持っている残りのノードも考慮する必要があります。 ここでは、もう一つのfind person関数を並列で実行できます。 再度、間違った予測をしているかもしれません。 テキストが増えると、間違いを正す能力が増えます。 ここでは、AMが正しく予想されるイベント時間などがあります。 その後、プログラムの依存性構造に従って残りの部分を実行し始めることができます。 実行タイムラインと発話タイムラインを重ね合わせることで、大幅に時間を節約できます。 そこで、オンライン意味論的構文解析のタスクを提案しました。 1つの基本的な仮定は、実行時間がモデル予測時間に大きく影響を与えるということです。 そこで早期に予測することで時間を稼ぐことができます。 もう1つの仮定は、予測と実行がバックグラウンドで行われるため、ユーザーには表示されないということです。 一貫した構文解析履歴を維持する必要はありません。 そこで，それぞれのトークン後に、ゼロから再解析します。 特に、2つのステップによるアプローチを提案します。 提案するステップでは、完全な構成を持つグラフと、現時点で実行する価値のあるノードを選択する選択ステップを予測します。 提案された方法には2つのバリエーションがありました。 最初のアプローチは、言語モデルの完了と完全な発話からグラフ構文解析を組み合わせたものです。 特に、オバマの後の接頭辞は、最初に細かく調整されたBART言語モデルを介して完成され、次に完全なオフラインパーサーを備えたプログラムに翻訳されます。 2番目のアプローチは、ユーザー発話接頭辞からプログラムを直接予測します。 これは、各接頭辞から目標グラフに変換するために、単一のオンラインパーサーを訓練することによって達成されます。 これで、モデルは正しい予測を容易に学ぶことができます。 もう少し詳しく説明すると、これらのグラフはどのように生成されるのでしょうか？ グラフのシリアルバージョンを生成することで問題を定式化します。 各ノードまたはエッジは、アクションによって表されます。 ここでは、最初のノードから開始します。 以下の数字は、アクション履歴の絶対指数を記録します。 そして、2番目のノードを取得しました。 次に、ノードの間のエッジです。 これには、前のノードのインデックスとエッジラベルへのポインタが含まれています。 ここでゼロとは、直近のノードを、ゼロ番目のアクションと次のノードの次のエッジによって生成されたノードと接続することを意味します。 このプロセスは、完全なグラフを生成するまで続きます。 基礎となるモデルは、トランスフォーマーに基づいており、以前のトランジションベースのパーサーに類似したセルフポインティングメカニズムを備えています。 完全なグラフを生成した後、グラフのさまざまな部分に対応するアクションレベルの確率を取得しました。 実行するしきい値ヒューリスティックに基づいて信頼度サブグラフを選択します。 後で、レイテンシ削減と実行コストの間で異なるトレードオフを達成するために、しきい値を変更します。 オンライン方法の正式な評価については、最終的なレイテンシ削減またはFLRメトリックを提案します。 以下は、オフラインのシステムが実行タイムラインをどのように終了するかの要約です。 オンラインシステムでは、実行は発話タイムラインと重複するため、より早く終了します。 FLRは、実行の終了によってマークされたオフラインシステムと比較した短縮時間として定義されます。 2つの大規模な会話型意味論的構文解析データセット、SMCalFlow、TreeDSTで実験を行います。 オフラインで動作するときのグラフベースのパーサーは、両方のデータセットで構文解析の最先端のパフォーマンスを達成します。 LMコンプリートモデルも、ノードコンプリートのシンプルなベースラインと比較して、重要なBLEUゲインを達成します。 では、グラフパーサーに対する接頭辞の予測の精度をみていきましょう。 y軸を各接頭辞の長さ、x軸をパーセンテージで表した評価データにおける生成とgoグラフの間のグラフタプルの一致F1スコアをテストします。 これらの曲線はそれぞれ異なるモデルを表し、訓練データだけに違いがあります。 下の曲線はオフラインのパーサーで、モデルをオンラインパーサーに移行するために、さまざまな長さの接頭辞データをミックスします。 たとえば、凡例の接頭辞80%プラスは、このモデルは完全な発話長の80%より長い接頭辞を持つ接頭辞データ を意味します。 左上隅が望ましいエリアです。 ご覧のとおり、黒い曲線のオフラインパーサーは、接頭辞データでうまく機能していません。 訓練でより多くの接頭辞をミックスするにつれて、曲線は上部と左側を持ち上がり、すべての接頭辞の長さでより良いパフォーマンスを発揮します。 ただし、右上の完全な発話構文解析パフォーマンスには影響しません。 これらの強力な結果に基づいて、どのくらいレイテンシを削減できるでしょうか？ ソーストークンの数で時間を測定し、異なる関数の実行時間をシミュレートします。 曲線は、FLRメトリックと実行コストの間のトレードオフを示しています。これは、正しくない過剰な関数コストの数値で測定されます。 これは、サブグラフ選択のしきい値を変化させることによって達成されます。 しきい値が高いほどミスの関数は少なくなりますが、FLRは小さくなります。一方、しきい値が低いほど、プログラムをより積極的に選択して実行します。 提案する2つのアプローチと直接オフラインパーサーをオンライン使用に適用するだけのベースラインを比較します。 左上の領域では、最良のFLRとコストのトレードオフがあります。 私たちの方法は両方ともベースラインを大きなマージンで上回っており、TreeDSTでも同様のパフォーマンスを発揮します。 個々の関数の実行はより速くなりますが、実行数が増え、レイテンシ削減の余地がある傾向があります。 個々の関数の実行が遅くなると、FLR改善の余地が広がります。 2つのアプローチは、異なるコスト領域でより良いパフォーマンスを実現します。 全体として、実行時間と許容コストに応じて、30〜63%の相対レイテンシ削減を達成します。 最後に、許可されたコストが3回の実行である場合の、関数ノードの各タイプのトークンにおける平均のレイテンシ削減の内訳を示します。 ご覧のとおり、まんべんなく利点があります。 find managerやrecipientなど、赤線がより長いところでは、大幅なレイテンシの削減が見られた関数もいくつか見られます。 これらは低レベルの関数であり、お互いにそれほど依存性がありません。 結論として、厳密なレイテンシ削減メトリックを使用して探索するための新しいタスクとしてオンライン意味論的構文解析を提案しました。 強力なグラフベースの意味論パーサーを使用して、LM補完ならびに完全なパーサーを備えた、または接頭辞で直接学習したパーサーを介したパイプラインアプローチのいずれでも、比較的良好なレイテンシ削減を達成しました。 また、私たちのアプローチは、一般的な枠組みになり得ます。他の実行可能なドメインの意味論の表現にも適用可能です。 今後の研究では、よりスマートな予測と実行統合方法を探求することができます。 ご静聴ありがとうございました。
こんにちは。 私たちの研究「質問に回答するタスクに対する取得強化された非現実節の生成」についてお話しします。 これは、Google Researchでインターンをしていた時に行った研究です。その際、Matthew LammとIan Tenneyに指導を受けました。 このタスクを始めるにあたって、まず非現実節を定義します。 この研究では 非現実節を、元のテキストよりもある意味のある制御された方法で異なる入力テキストのゆるぎと定義します。 そして、出力やタスクラベルでの変化について推論することができます。 たとえば、fascinatingをcaptivatingへ、または expectedをmind-numbingへと単語を変更することは、映画批評の感情を変えます。 同様に、質問にwomen's という修飾子を追加すると、以下の例の質問に対する応答が変わります。 人間は、タスクで訓練された自然言語処理モデルと比較すると、そのようなゆらぎに対して堅牢です。 なぜでしょうか？ データセットには、体系的なバイアスをもって抽出されている可能性があり、非現実節によって違反となるシンプルな決定境界につながります。 この2Dの分類問題に示されているように。 私の研究では、訓練データに非現実節の例を追加すると、モデルがそのようなゆらぎに対して堅牢になることがわかりました。 それでは、非現実節が価値あるものであるならば、どのようにしてそれらを生成することができるのでしょうか？ このタスクは、3つの異なる自然言語処理タスクからの3つの例があるため、自然言語処理タスクにとって特に難しいです。 ご覧の通り、出力間で決定境界に違反した例は、下線を引いたテキストのいくつかの属性にゆらぎを与えることで、注意深く作る必要があります。 これは、人間の注釈によって達成できますが、高価であり偏りがでます。 いくつかの過去の研究は、構文ツリーや意味論的ロールラベリングに焦点を当てていました。 しかし、これらのテクニックにより生成されたゆらぎのセットは、意味論の枠組みによって限界がありました。 最近の研究では、マスクした言語モデルを使用して、テキストのマスクした部分を埋めて、ラベルを変更しました。 しかし、テキストのどの部分がゆらぐかを見つけることは困難です。 特に、質問への回答の為の非現実節の生成はより困難です。 このタスクには、背景となる知識が必要です。 たとえば、インディ・ジョーンズ/ 魔宮の伝説の前編ですか？という質問にゆらぎを与えるとします。 レイダース／失われたアークは前編ですかという質問に達するには、フランチャイズの他の映画を認識する必要があります。 さらに、ランダムなゆらぎは、利用可能な証拠を用いて回答ができないか、誤った前提の質問につながる可能性があります。 また、ある質問のゆらぎが、元の入力から大きく意味論的に離れる可能性があります。 たとえば、インディアナ・ジョーンズは魔宮で児童奴隷制を実践しているのか？などの質問です。 私たちは、非現実節的質問のゆらぎに対抗し、すべての他の前述の課題に取り組むことを目標として、取得生成フィルターRGFと呼ばれる、非常にシンプルかつ高価的なテクニックを提案します。 RGFの背後にあるコアの直感は、ゆらぎの生成に必要な背景情報は、質問回答モデルによってニアミスで存在する可能性のあるということです。 たとえば、最先端のモデルであるREALMは、リッチモンドフットボールクラブのキャプテンは誰ですか？」と言う質問に対して、次のトップk回答を「生成します。 これは元の参照する一説を回復し、トレント・コーチンを最も多い選択肢として回答します。 これはまた、質問のゆらぎを導くことのできる、追加の一説と回答を取得します。 たとえば、リザーブチームと同じクラブの女性チームのキャプテンに対応する2つの回答を回復し、これが興味深い編集となる可能性があります。 要約すると、RGFはまず、文脈内の参照応答と一致しないトップkの最も関連性の高い応答と文脈を取得します。 このステップに従って、質問生成 モデルは、これらの代替え回答の条件として、それらに対応する質問を生成します。 そして最後に、最小性、または導入に興味のある意味論的なゆらぎのタイプに基づいて生成された質問を絞り込むことができます。 取得についてより詳細に各ステップを検討すると、取得を使用した後、元の質問を入力とするREALM のようなモデルやWikipediaのような大規模なコーパスを読みます。 これは2つのモジュールで構成されています。 Retrieverモジュールは、類似性検索を一節の高密度インデックス上で実行し、質問に最も関連性の高い上位k個の一説を取得します。 そして、readerモジュールは、潜在的な応答として各一節からスパンを抽出します。 ほとんどの場合、REALMは非常に優れた一節と応答を取得します。 しかしこの研究では、応答とその先で取得される文脈に、より興味があります。 次のステップの質問生成で私たちは、これらの代替回答と文脈を使用して、これらの代替えに対応する新しい質問を再生成します。 質問生成モデルは、事前訓練されたテキストトゥテキストトランスフォーマーです。これはNQデータで微調整され、文脈にマークされた応答の為の質問を生成します。 推論では、質問生成モデル、以前のステップで回収された代替応答、文脈をフィードしました。 たとえば、リッチモンド・フットボールクラブのキャプテンは誰ですか？という疑問にはREALMは、ジェス・ケネディがキャプテンをつとめるクラブの女性チームについての一説を取得し、そして質問生成モデルは、リッチモンド・フットボールクラブの最初の女性チームのキャプテンは誰ですか？という疑問を生成します。 これには、特定の意味論的なゆらぎがあります。 同様に、リッチモンドのVFLリザーブチームのキャプテンは誰ですか？ または、去年グラハムが決勝で勝った相手は誰ですか？といった質問も得られます。 最後に、ある望ましい特性に基づいて、生成された質問のサブセットを絞り込みます。 前述で動機づけられるように、新しい質問がまだ意味論的にオリジナルに近いことを確認したいと思います。 追加の監督を必要としない絞り込みのテクニックについては、単純に元の質問からトークンラベル編集の距離が小さい、新しい質問を維持します。 たとえば、私たちは昨年決勝でグラハムが勝った相手は誰ですか？という質問を削除します。 これは元の質問からの編集距離が長いからです。 実験では、訓練データを強化して、キューに入れるためにシンプルなヒューリスティックを使用できることを実証しました。 意味論的なゆらぎの種類に基づいた絞り込み戦略も実験しています。 この目的のために、QEDと呼ばれる汎用質問分解フレームワークを使用します。 QEDは、質問の2つの部分、述語と参照を識別します。 参照は、文脈内のエンティティに対応する質問内の名詞句です。 述語は基本的に質問の残りの部分です。 たとえば、リッチモンド初の女子チームのキャプテンを務めたのかという疑問を、リッチモンド・フットボールクラブの女子チームと誰がキャプテンを務めたかという述語の2つの参照に分解することができます。 NQの為に参照述語の注釈で訓練したモデルにより、この質問を分解できます。 QEDに基づいた元の質問と生成された質問の両方を分解することにより、評価の為に生成された非現実節を分類することができます。 具体的には、2つのグループの質問を取得します。 述語を保持しながら参照の変更を受けるもの、述語の変更を受けて任意に参照を追加するものです。 たとえば、「リッチモンドのVFLリザーブチームのキャプテンは誰ですか？」は参照の変更でしょうか？ 「クラブで背番号9をつけているのは誰ですか？」というのは、述語の変更です。 訓練データに強化されたときのRGFのゆらぎの有効性を評価します。 特に非現実節の拡張の有効性を効果的に評価するために、2つの強力な データ拡張 ベースラインで実験しました。 最初のベースラインは、ランダム応答と質問生成と呼ばれ、元の質問にリレーションのないデータを追加します。 つまり、一説と応答は、単純にWikipediaからランダムにサンプルを抽出します。 このベースラインは基本的に、NQのように見えるデータを追加します。 2つ目のベースラインはゴールド回答と質問生成で、方法の取得部分をアップデートします。 ここでは、代替えの回答は、ゴールド応答を含む同じ一節からただ選択します。 ベースラインと RGF拡張は、モデルに質問と文脈にアクセスできる読解でどのように機能するでしょうか？ 私たちは、ドメインデータセット中の6つで実験をし、ここで結果を提示します。データは訓練データで、拡張で2倍になります。 データ拡張ベースラインの両方は、ドメインの一般化を改善できないことがわかりました。 実際、元のデータで訓練された6つのモデルの組み合わせが、最も競争力のあるベースラインであるようです。 そのベースラインと比較して、RGF非現実節は、ドメインパフォーマンスで維持しながら、ドメインパフォーマンスを向上させることができることがわかりました。 これは、非現実節を増大させてモデルの推論ギャップを埋めることは、訓練分布からより多くのデータを追加するよりも、より効果的であることを示唆しています。 さらに、私たちは、代替え出力や回答をサンプル抽出するために取得を使用することは、効果的なCDAの為に重要であることがわかりました。 モデルが質問だけを見て、再びドメインデータセット中4つで評価する、オープンドメインQA設定でも実験を行いました。 ベースラインのモデルは ドメイン外の一般化では効果的ではないことがわかりました。 しかし、RGFによるデータ増大は、より顕著な改善を示します。 ドメインNQデータセットでも改善します。 非現実節のデータ増大は、非常に似た疑問のより良い疑問のエンコーディング学習でモデルを支援すると仮定しました。 最後に、モデルの元の質問のローカル周辺の一貫性を向上させる能力も評価しました。 一貫性は、元の疑問と非現実節の疑問を正しく回答したモデルが正しく回答した質問の割合を測定します。 これは、元の入力の周りの小さなゆらぎに対するモデルの堅牢性を測定するのに明示的に役立ちます。 意味論的にお互い近い質問のペアを含む5つのデータセットで実験しました。 すでに利用できるAQA、AmbigQA、QUOREFコントラストセットの3つのデータセットとは別に、述語変更または参照変更が起きたかどうかに基づき、元のNQ質問と組み合わされたRGF 非現実節を評価します。 これらのサブセットは、ノイズを除去するために内部で注釈付けされ、リソースとして提供されます。 すべてのベースラインは大幅に一貫性を改善できず、アンサンブルモデルは小さなマージンで一貫性を改善しました。 しかし、RGF非現実節の増大は、以前のデータセットと、参照と述語のゆらぎの為にキュレーションした2つのサブセットの両方で一貫性が大幅に向上しています。 なお、強化されたRGFデータはゆらぎの種類によって偏るのではなく、評価セットによって偏ることに注意してください。 実際、生成された非現実節の質的検査では、生成された質問には、多様なゆらぎがいくつか含まれていることを示しています。 たとえば、ミネソタ週のウォルナットグローブの人口に関する元の質問は、街、州、郡などの異なる次元や、場所、貧困、学校の数などの異なる述語でゆらいでいます。 ゆらぎの音声は文脈固有です。 たとえば、ウィンブルドンのシングルストーナメントに関するこの質問では、試合の種類、トーナメントの種類、試合結果に関してゆらいでいます。 最終的な教訓は次のとおりです。非現実節のデータ拡張と質問を求める情報のゆらぎのタスクに取り組み、モデルのニアミスや、ゆらぎの種類や最小性に基づいた絞り込みを使用した、いくつかの生成アプローチを介してユニークな課題に取り組みます。 このテクニックは追加の監督を必要とせず、例は拡張の為にラベル付けされていることがわかります。 拡張はドメイン一般化と周辺の一貫性を改善します。 また、RGF非現実節は拡張中にバイアスをもたらすことなく意味論的に多様であることがわかります。 ご清聴ありがとうございました。
こんにちは、エレナです。これから私たちの研究、スペイン語における同化されていない借用の検出： 注釈付きコーパス とモデリングへのアプローチについて発表します。 語彙的借用とは何か、ご提案するタスク、リリースしたデータセット、探索したモデルについてお話します。 しかしまず初めに、語彙的借用とは何か、そしてなぜこれが自然言語処理タスクで重要なのかについてお話しします。 語彙的借用は基本的に単語を1つの言語から別の言語に組み込むことです。 たとえば、スペイン語では英語からの単語を使います。 ここで例をあげると、ポッドキャスト、アプリ、そしてオンラインクラウドファンディングなどの単語はすべて、スペイン語で時々使われる英語の単語です。 語彙的借用は、基本的に他の言語をある言語パターンで再生する一種の言語的借用です。 そして、バイリンガルの人が2つの言語を同時に混合することのように、借用とコードの切り替えは、時として連続したコードの切り替えと比較され、説明されます。 ただし、語彙的借用とコードの切り替えにはある違いがあります。 ここでは語彙的借用に焦点を当てていきます。 コードの切り替えはバイリンガルが行うもので、その定義からすると、コードの切り替えは使われたどの言語にも統合されていません。一方、語彙的借用はモノリンガルも行います。 借用は、受け入れ言語の文法に準拠します。 そして借用は、やがて受け入れ側の言語に組み込まれていきます。 では、なぜ借用は興味深い現象なのでしょうか？ 言語学の観点から言えば、借用は言語がどのように変化し、どのように相互作用しているかの表れです。 そして、語彙的借用は、新しい単語の源でもあります。 ここで、スペイン語に新しい単語として組み込まれた語彙的借用の例をいくつか見てみましょう。 自然言語処理の面で借用は、語彙にない単語の一般的な源です。 実際、自動的に 語彙的借用を検出することは、構文解析、テキスト-トゥ-スピーチ合成、または機械翻訳など、自然言語処理の下流タスクの為に有用です。 英語の他の言語に対する影響、特に英語の語彙的借用についてについて関心が高まっており、この借用はアングリシズムと呼ばれます。 そしてこちらでは、これらの言語における借用の自動検出に関する研究例を幾つかご紹介します。 私たちが提案するタスクは、スペイン語のニュースワイヤーにおける同化されていない語彙借用を検出することです。 ここでの目的は、スペイン語の新聞で使用されている他の言語から借用した単語で、受け入れ側の言語に統合または同化していない単語を抽出することです。 つまりスペイン語にはまだ組み込まれていません。 ここに例があります。 このスペイン語の文章：Las prendas bestsellers se estampan con motivos florales, animal print o retales tipo patchwork. ご覧の通り、3つのスパンの テキスト、つまりベストセラー、アニマルプリント、パッチワークといった英語の単語があります。 これらは、抽出と検出が興味深いスパンのタイプです。 アングリシズム検出で以前に単語があり、それらは スペイン語ニュースワイヤーにおけるアングリシズム検出の為のCRFモデルで構成されています。 このモデルは86のF1スコアを達成しました。 しかし、データセットとモデリングアプローチの両方には限界があります。 データセットは特に、ニュースのソースの一つ、ヘッドラインだけを含んでいます。 そして、訓練セットとテストセットに出現する借用語には重複もあります。 これにより、モデリングアプローチが以前の見えない借用語を実際に一般化するかどうかの評価ができません。 ですから、このタスクにおけるこれらの制限に取り組むことが目標です。 まずは、新しいデータセットを作成します。 語彙的借用で注釈付き新しいデータセットを目指し、できるだけ難しいテストセットを作成することを目指しました。 したがって、訓練セットとテストセットの間の単語とトピックスの重複が最小限になります。 その結果、テストセットは訓練セットでみられないソースと日付からきています。 ここでは、時間内に重複がないことがわかります。 また、テストセットも非常に借用語が多いです。 数値をあげると、もし訓練セットに、各1,000トークンにつき6つの借用が含まれていると、テストセットには各1,000トークンにつき20の借用が含まれています。 テストセットには、できるだけ多くの語彙単語が含まれていました。 実際、テストセットの借入語の92%はOOVです。 そのため、訓練中には見られませんでした。 そして、コーパスは基本的にスペインの新聞のさまざまなソースから来たテキストのコレクションで構成されていました。 それは二つのタグを使って手作業で注釈付きにされました。 一つは、英語の語彙的借用語の為、スペイン語では大多数を占める語彙的借用語で、もう一つのラベルはその他の言語からの借用語の為です。 CONLL形式で、BIOエンコーディングを使ったので、アプリなどの単一トークン借用語や、機械学習などのマルチトークン借用語をエンコードしました。 これらはコーパスの数です。 ご覧のとおり、それは約37万トークンに相当します。 ここに、英語としてラベル付けされたスパンの数と、他の借り入れとしてラベル付けされたスパンと、そのうちでユニークであった数があります。 ここでは、データセットのセットの例をいくつか示します。 インスタンスの為にここで確認できることに、最初の例では、マルチ単語借用語、batch cooking（バッチクッキング）があります。 そして、BIOエンコードで注釈付きを行いました。 BIOはスペイン語の単語の為に使ったので、借用されていない単語ではありません。 2つ目の例では、英語からの借用語としてラベル付きになっている、benchingとcrashがあります。 そこでデータセットが手に入った後、これらの語彙的借用を抽出して検出するタスクの為のモデルをいくつか検討しました。 最初に試したのは、条件付きランダムフィールドモデルでした。 これは以前の作業で使用されていたモデルでした。 そしてその研究からの同じ手作りの機能を使用しました。 これらが機能です。 大文字の単語やトークンなどのバイナリの機能ですか？ 見出しのために大文字になっているのでしょうか？ 引用符ですか？ 名前付きエンティティ認識タスクで期待される機能の種類です。 これらが得られた結果です。 手作りの機能によるCRFモデルを使って、F1スコア、55を得ました。 これは、スペイン語の語彙的借用検出の為に、同じCRFモデル、同じ機能で、異なるデータセットを用いたのF1スコア、86と比較すると、大きな違いがあります。 これにより、作成したデータセットはより難しく、これらのタスクの為に、より洗練されたモデルを探索する必要があることがわかりました。 そこで、2つのトランスフォーマーベースのモデルをテストしました。 私たちは、スペイン語の為に訓練された単一言語BERTモデルと多言語BERTを使いました。 両方のモデルは、HuggingFaceのトランスフォーマーライブラリを介して使用しました。 これらが得られた結果です。 ご覧のとおり、多言語BERTは、開発セットとテストセットの両方、およびすべてのメトリックスでBETOよりも優れています。 比較するアイデアがあったので、CRFモデルでは82を得ました。 CRFモデルのF1スコアは55です。多言語BERTの82とは大きな差があります。 これらの結果を得た後、もう一つの質問に直面しました。BiLSTM-CRFモデルを見つけ、異なる種類の埋め込みを行い、これらの埋め込みにさまざまな種類の言語的情報をエンコーディングすると、トランスフォーマーベースのモデルで得られた結果より優れたパフォーマンスを発揮できるでしょうか？ そのために、フレアライブラリを使ったBiLSTM-CRFモデルで予備的な実験を行いました。 トランスフォーマーベース、ファーストテキスト、文字埋込みなど、さまざまな種類の埋込みで実験を試みました。 トランスフォーマーベースの埋込みは文脈で理解できる埋込みよりも優れており、英語 BERTとスペイン語BETO埋込みの組み合わせは多言語 BERT 埋込みよりも優れていることがわかりました。 BPE埋込みはF1の結果が優れていました。文字埋込みはリコールで優れていました。 それを念頭に置いて、これらは私たちが得た最高のパフォーマンスの結果です。 どちらのモデルも、フレアを使用したBiLSTM-CRFモデルでした。 1つはBETOとBERT埋込みとBPEがフィードされ、もう1つはBETOとBERT 埋込みとBPEと文字埋込みもフィードされました。 この最後のものが、テストセットで最高のF1スコアを生成したものでした。しかし開発セットでの最高のスコアは文字埋込みのないものによって得られました。 多言語BERTでの最高のF1スコアは、開発セットで76、テストセットで81であったことにご留意ください。 これはその結果に比較して改善されています。 最後に、コード切り替えにおける言語識別から語彙借用検出を転移学習として捉えることができるかという、別の質問を考えました。 そこで、フレアを使用して実行したのと同じBiLSTM-CRFモデルを実行しますが、これらの非適応のトランスフォーマーベースのBETOとBERT埋込みの代わりに、コード切り換え埋込みを使用しました。 コード切り換え埋込みとは何か？ これらはトラーンスフォーマーベースで丁寧にチューニングされた埋込みです。LinCEコード切り換えデータセットのスペイン語、英語セクションで言語識別の為事前訓練されたものです。 LinCEは、コード切り替えに関するデータセットで、スペイン語英語、スペイン語英語のコード切り替えに関するセクションがあります。 そこで、BiLSTM-CRFにコード切り替え埋込みと任意の文字埋込み、BPE埋込みなどをフィードしました。 得られた最高の結果は84.22でした。これはテストセットで試したすべてのモデルの中で最高の結果です。 開発セットで得られた最良のF1スコアは79でしたが、順応されていない埋込みがフィードされたBiLSTM-CRFで得られた最良の結果よりも低いものでした。 私たちの研究からのいくつかの結論となります。 同化されていない語彙的借用を伴う注釈付きスペイン語ニュースワイヤーの新しいデータセットを作成しました。 このデータセットは、以前のリソースよりも借用が多く、OOVが豊富です。 語彙的借用の検出の為の4種類のモデルで調査しました。 ええ。誤差分析で、リコールはすべてのモデルにおいて弱点でした。 こちらで確認できるように、大文字の借用単語で、英語とスペイン語の両方に存在するものが、頻繁に検知漏れになっています。 また興味深いことに、BPE埋込みはF1スコアを向上させるようです。 そして、文字埋込みはリコールを改善しているようです。 これは興味深い発見であり、今後の研究でさらに調査することができるかもしれません。 ええ。これで発表は終わりです。 ご清聴いただき、本当にありがとうございました。
アントワーヌと申します。 マサチューセッツ大学アマースト校の博士課程の学生です。 KinyaBERT: 「語形論-キニアルワンダ語の言語モデルを認識する」という論文をご紹介します。 本日は、この研究の為の動機についてお話しします。 その後、KinyaBERTモデルのアーキテクチャの詳細を紹介します。 そして、実験結果について話し、結論をいくつかお伝えします。 最近の自然言語処理の進歩は、BERTのような事前訓練された言語モデルの使用によって可能になったことは誰もが知っています。 しかし、制限はまだいくつもあります。 ほとんどの形態的に豊富な言語によって表現される複雑な形態素のために、私が使用したユビキタスなバイトペア符号化されトークン化されたアルゴリズムは、効果的な表現のために必要な正確なサブ単語の語彙的な単位、つまり 形態素を抽出することができません。 たとえば、こちらのキニアルワンダ語の3つの単語には形態素がいくつかありますが、BPEアルゴリズムはそれらを抽出できません。 これは、形態的な規則が正確な語彙情報を隠すさまざまな表面形態を生成し、表面形態のみに基づいたBPEがこの語彙モデルにアクセスできないためです。 2つ目の課題は、Oracle形態素アナライザーにアクセスできたとしても、BPEトークンを形態素に置き換えるだけでは、形態的構成の可能性を表現するのに十分ではないということです。 研究における3番目のギャップは、新しい事前訓練された言語のモデルがリソースが豊富な言語で最も頻繁に評価されることです。 また、リソースがあまりない、多様な言語への適用性も評価する必要があります。 したがって、形態素が豊富な言語をより効果的に扱うために、BERTアーキテクチャをシンプルかつ効果的に適応させたKinyaBERTを発表します。 低リソースで形態素が豊富な言語のキニアルワンダ語で、KinyaBERTを評価します。キニアルワンダ語は東部および中央アフリカで1,200万人以上の方々が話す言語です。 モデルへの入力は、文または文章のいずれかです。 たとえばこちらには、「John twarahamubonye biradutangaza」という文章があります。「私たちはそこでジョンを見つけてびっくりした」という意味です。 ご覧のとおり、キニアルワンダ語の単語には、異なる情報を含む形態素がいくつか含まれています。 したがって、私たちのモデルでは、この文または文章を形態素アナライザーに渡します。 それからそれぞれの単語に含まれる形態素を生成します。 形態素は通常、語幹とゼロ以上の接尾辞で構成されます。 接尾辞は、時制、アスペクト、動詞の主語または目的語を示すことができ、主語および目的語のためのバントゥー語の名詞クラスに関連することが多いです。 形態素アナライザーは、各単語の為のスピーチタグの一部も生成します。 このステップの後、スピーチタグの一部の為に埋込みを用意します。 接尾辞の為の埋込みです。 そして語幹の為の埋込みです。 これらは、語形論レベルであり、語形論レベルの埋込みです。 次に、これらの埋込みを語形エンコーダに渡します。これは、各単語に独立して適用される小さなトランスフォーマーエンコーダです。 そして、各単語で形態的情報がついている、文脈で理解できるベクトルが出力されます。 それでは、スピーチと語幹に対応する形態的埋込みが連結される合成を行います。 さらに、文章レベルで他の語幹の埋込みを合成します。 次に、メインの文または文章エンコーダへの入力を形成します。 最終的な出力は、下流自然言語処理タスクに使用できる文脈で理解できる埋込みです。 形態素アナライザーでは、キニアルワンダ語に合わせてカスタム実装された有限状態2レベル語形論原則を使用します。 口語、名詞、指示代名詞、所有代名詞、数字などを含むすべてのキニアルワンダ語の語形を効果的にモデリングします。 スピーチタグ付けアルゴリズムの監視なしの部分を使用します。 一次因子モデルを使用して、語形の確率、つまり形態素アナライザーによって割り当てられた確率を説明します。 また、スピーチタグの優先と、入力単語に存在する構文合意も考慮します。 スピーチのタグ付け部は、双方向推論を使っており、より頻繁に使われるデコーディングの為のビタビアルゴリズムよりも優れています。 ここで、位置的エンコーディングの為の注意事項を少し紹介します。 1つ目は、形態素エンコーダは位置的エンコーダを使用しないことです。 これは、各形態素が形態的モデル内の既知のスロットを占有しているためです。 したがって、位置情報は、形態素が与えられたときに内在します。 第二に、文エンコーダは、最近ICLRカンファレンスで公開されたいわゆる不拘束の相対位置の埋込みを使用します。 この位置的埋込みは、トークンからトークン アテンション計算へ、位置相関を本質的に分離します。 BERTと同様に、マスク言語モデル事前訓練の目的を使用します。 本質的には、単語に関連付けられている語幹と接尾辞の両方を予測する必要があります。 事前訓練では、すべての単語の15%が予測と見なされ、そのうち80%がマスクされ、10%がランダムな単語と交換され、10%は変更されません。 接辞の予測では、複数のラベルの分類に関する問題に直面します。 この為には、接辞を固定した数でセットグループ化し、クラスラベルとしてセットを予測するか、 もしくは、接辞の確率ベクトルを予測することです。 この2つのアプローチを実験で計測しています。 KinyaBERTを約2.5ギガバイトのキニアルワンダのテキストで事前訓練し、3つのベースラインモデルと比較します。 一つは多言語モデルで、XLM-Rと呼ばれ、複数の言語で作られた大規模なテキストコーパスで訓練されています。 他の2つのベースラインは、同じキニアルワンダ語のテキスト上で事前訓練されたものです。バイトペアエンコーディングアルゴリズムを使用するか、2層トランスフォーマーエンコーダアーキテクチャを使用せずに形態分析を使用して、事前訓練されます。 すべてのモデルは1億から1億1千万のパラメータからなる基本のアーキテクチャで構成され、最小の数のパラメータを使用したKinyaBERTを持つキニアルワンダ語を使用します。 多言語を除くすべてのモデルは、32,000の傾度の更新で事前訓練されたものです。各更新のバッチサイズは2,560のシーケンスです。 事前訓練されたモデルは、3つのタスクセットで評価されます。 1つは、事前訓練された言語モデルの有効性を評価するためにしばしば使用されてきたGLUEベンチマークです。 GLUEベンチマークデータは、元のベンチマークデータをGoogle翻訳でキニアルワンダ語に翻訳して取得します。 2つ目のタスクはキニアルワンダ語の名前付きエンティティ認識ベンチマークで、訓練を受けたネイティブスピーカーによる注釈付きの、高品質のデータセットです。 3つ目はニュース分類タスクです。複数のウェブサイトからニュース記事を取得し、著者によって割り当てられた分類タグを収集し、基本的に同じカテゴリを予測します。 それでは、結果に移ります。 GLUEベンチマークでは、KinyaBERTがベースラインモデルを一貫して上回っていることがわかりました。 ここでは、10件の微調整の実行結果の平均値を示します。 また、Google翻訳によって生成された翻訳のユーザー評価も実行します。 基本的に、ユーザーは約6,000の例を評価し、1から4のスケールでスコアを割り当て、翻訳の品質を評価しました。 その結果、多くの翻訳はノイズが多くなりました。 しかし、すべてのモデルは同じ翻訳ノイズに対処しなければならず、モデル間の相対的なパフォーマンスは依然として注目に値します。 名前付きエンティティ認識タスクでは、KinyaBERTが、最高のパフォーマンスを示し、接辞分布回帰バリアントが最高のパフォーマンスを示すことがわかりました。 これらの結果は、10回の微調整の実行結果の平均でもあります。 ニュース分類タスクについては、さまざまな結果が確認できます。 以前のキニアルワンダ語のテキスト分類の研究では、単純なキーワード検出がこの特定のタスクを解決するのに十分であることがわかりました。 したがって、事前訓練された言語のモデルを使用することで得られる利益は少なくなります。 このニュース分類の特定のタスクについて。 また、パフォーマンスを向上させる代替構造があるかどうかを調べるためにアブレーション研究を実施しました。 GLUEベンチマークでは、接辞セットを使用すると一貫してパフォーマンスが向上し、名前付きエンティティ認識で接辞確率回帰目標では、最高のパフォーマンスが得られることがわかりました。 また、微調整の低スコアを見ると、KinyaBERTはほとんどの場合、収束性が優れていることがわかります。 結論として、この研究は、事前訓練された言語モデルで形態的情報を明示的に使用することの有効性を実証しています。 提案された2層のトランスフォーマーエンコーダアーキテクチャは、形態的に豊かな言語の重要なアスペクトである形態的複雑性、形態的構成の可能性を捉えることを可能にします。 これらの知見は、語形論を認識した言語事前訓練された言語モデルのさらなる研究を動機づけるはずです。
こんにちは。Michał Pietruszkaと申します。『訓練可能な表現プーリングによるトランスフォーマーモデルの分散』と題した論文をご紹介します。 これは、Lukasz BorchmannとLukasz Garncarekとの協力で、Applica AIで行われた研究です。 まずは、私たちの研究の目標についてお話しします。 私たちの方法は、長いインプットが考慮される場合にうまく機能します。 大まかに言えば、それは2,000トークン以上のタスクオーダーと入力を意味し、ターゲットは提供された入力よりも短いです。 これは自然言語処理での特定のアプリケーションがいくつかあります。 たとえば、長い文章があれば、それを要約し、分類し、質問に応答し、情報またはいくつかの重要なフレーズを抽出する必要があると想像できます。 バニラトランスフォーマーと入力ラインの2乗に依存する、アテンションの複雑さの問題を思い出してください。 バニラトランスフォーマーでは、完全なアテンション接続で、各トークンと他のトークンとのrelationsを計算する必要があります。 アテンションの計算の複雑さは、レイヤーlの数、シーケンスの長さ、別のシーケンスの長さ、および表現の次元に依存します。 同様に右側のこの画像に、デコーダのクロスアテンションがあります。ここでの唯一の違いは、ターゲットトークンがこの場合入力トークンに参加していることです。 これはこの公式にも見て取れます。 BLEUスコアは、計算する必要があるrelationsを表します。 完全なアテンションの場合、入力シーケンス内のすべてのrelationsを計算する必要があります。 これで、トークンの接続性を制限して、近くの他のトークンのみを見ることができるようにするブロックワイズエンコーダがある場合、何が起こるかがわかります。 テキストはチャンクで読み取られ、エンコーダ側の計算の数を大幅に減らすことができますが、すべての入力トークンがデコーダに渡されるため、デコーダのクロスアテンションは改善されません。 この方法は、デコーダでの融合と呼ばれることが多くあります。 ここでの改善は、nの依存関係の1つを、ブロックサイズを表す別の定数mに変更するものと解釈することができます。 観察できた重要な点は、ほとんどのトークンは多様なタスクには無関係であり、ほぼ完全に無視することができるということです。これはスライドに例示されています。 入力のうち、目的の出力に関係する部分だけです。 例えば。 記事を一度読んで、最も重要な部分を蛍光ペンでマークして、中間段階のこの部分に基づいて要約を作成します。 ハイライトと現在のトークンが要約の作成に不可欠であるかを判断するコストは安価であり、トークンの表現のみに依存します。 ハイライトされたトークンのプールが可能です。 トップkオペレーターのおかげで、そのコストは無視できます。 短縮された入力から要約を作成するコストも、全体入力を考慮した場合のバニラモデルよりもはるかに低くなります。 しかし質問があります。 重要なトークンを選択するには、そして、その選択に傾度を逆伝播するにはどうすればよいでしょうか？ 解決すべき根本的な問題は、訓練可能な選択メカニズムを提案することです。 ネットワークが最も重要なトークンを選択することを学習できるように、訓練中に傾度を逆伝播できるものです。 より正確には シンプルな線形レイヤーから得た埋込みアンダースコアをいくつか与えると、タスクは最高のスコアの埋込みを返します。まず、シーケンスの順序を変え、より高いスコアのベクトルとより低いスコアのものを組み合わせるようにペアを準備します。 次に、スコアに対してブーストされたsoftmaxを使用して荷重を計算します。 各トーナメントラウンドの後、新しいベクトルとスコアは、取得した荷重とペアになった線形の組み合わせになります。 要するに、スコアに対してsoftmaxを実行することによって、それらを線形に結合します。 2つのトークンを組み合わせると、いくつかのノイズが生成されることがあります。 また、勾配をすべての入力埋込みに伝播させることもできます。 つまり、提案した訓練可能なトップkは、各ステップでトーナメントのような柔軟な選択を行うことに基づいています。 別の観点から見ると、表現プーリングはエンコーダレイヤーに従います。 まず、各表現がスコア付けされます。その後、最も高いスコアを持つものだけが次のレイヤーに渡されます。 エンコーディングは、標準のトランスフォーマーアーキテクチャの全長の入力として実行できます。 ただし、テキストを固定長ブロックで処理し、最適な表現をグローバルに選択することは可能です。 以下は、エンコーダの後に導入された表現プーリングの例です。 これはクロスアテンションの原因に直接影響を与えました。クロスアテンションは入力長Nではなく、プールされた長さを表す定数Kに依存します。 この定数は、いくつの表現が選択され、デコーダに渡されるかを知らせるものです。 より短いテキストから要約を作成することは、以前のソリューションよりも大幅に安価です。 シーケンスの長さが大きな要因によって短くなる可能性があるからです。 たとえば実験では、nの値より16倍、あるいは64倍も小さなkを使うことができました。 ブロックワイズのエンコーディングとセルフアテンションの有益な影響は維持されることに注意してください。 アテンションの計算コストは、入力の長さの2乗に依存することを忘れないでください。 エンコーディングプロセスの早い段階で入力を減らすことで、大幅にコストを削減できます。 ピラミディオンモデルでは、選択した各レイヤーの出力への表現サイズを絞り込むことで、エンコーディングプロセスが進むにつれ、計算コストが大幅に削減しました。 ご覧の通り、フルのエンコーダの計算コストの合計は、フルサイズの最初のレイヤーのコストの1/2未満です。 プーリングがこれより前に導入された場合、すべての紫の正方形の合計は、レイヤーIの数に依存せず、定数に制限されます。 しかし定数cでは、ネットワーク内でのプーリングレイヤーの配置に影響を受ける可能性があります。 改善により、8,000トークン長の入力が基準となりました。 この図は、プーリングが行われると、ネットワークの深さに最適なスケーラビリティが達成されることを示しています。 ここで注意すべきは、そのような長い入力では、24層のプラミディオンを訓練するほうが、2層のバニラトランスフォーマーの訓練よりも安価であり得ることです。 そのような長い入力では、バニラトランスフォーマーがどれだけ簡単にメモリ不足になるかは言うまでもありません。 トレンドピラミディオンと他のベースラインとの質的比較は、長い文章の要約タスク、またはarXivまたはPubMedの記事の本文から、摘要を生成するタスクで実行されます。 このように、私達のベースラインであるブロックワイズは、最近の最新技術モデルであるREと同レベルの性能を示し、ピラミディオンはこの競合のベースラインの性能を維持または向上させていることがわかります。 同時に、私たちのモデルは、ブロックワイズベースラインと比較して、80%早く訓練することができ、450%以上早く推論できます。 これらのモデルは両方とも、パラメータカウントがより低く、選択したタスクではじめから訓練されました。 同様のパフォーマンスを達成した以前のアプローチは、同様のパフォーマンスを達成するために、より多くのパラメータを使用し、事前訓練された基盤モデルと、加えて言語事前訓練の目標を活用する必要がありました。 ぜひ、論文を全てお読みいただき、GitHubのコードもご利用ください。 ご覧頂き、ありがとうございました。
